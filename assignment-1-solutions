;;; Represent set as list w/o repeated elements

(define set-cardinality length)

;;; Auxiliary function, removes repeated elements
(define uniq 
	(lambda (xs)
		(cond ((null? xs) xs)
			  ((member (car xs) (cdr)) (uniq (cdr xs)))
			  (else (cons (car xs) (uniq (cdr xs)))))))
						  
(define set-union (lambda (s1 s2) (uniq (append s1 s2))))

(define set-intersection 
	(lambda (s1 s2)
		(cond ((null? s1) s1)
			  ((member (car s1) s2)
			   (cons (car s1) (set-intersection (cdr s1) s2)))
			  (else (set-intersection (cdr s1) s2)))))
			  
(define set-difference
	(lambda (s1 s2)
		(cond ((null? s1) s1)
			  ((member (car s1) s2)
			   (cons (set-difference (cdr s1) s2))
			  (else (cons (car s1) (set-difference (cdr s1) s2)))))))
			  
(define set-equal?
	(lambda (s1 s2)
		(and (null? (set-difference s1 s2))
			 (null? (set-difference s2 s1)))))
			 
(define set-map-join
	(lambda (f s)
		(foldl set-union '() (map f s))))

(define free-variables
	(lambda (e)
		(cond ((symbol? e) (list e)) 	; variable
			  ((equal? (car e) 'lambda) ; lambda expression
			   (let ((param (cadr e))
					 (body (caddr e)))
				 (set-difference (free-variables body)
								 (list param))))
					 
			  (else 					; application
				(set-union (free-variables (car e))
						   (free-variables (cadr e))))))
						   
(define beta-reduce
	(lambda (e)
		(cond ((symbol? e) #f) 	; variable
			  ((equal? (car e) 'lambda) ; lambda expression
			   (let ((param (cadr e))
					 (body (caddr e)))
				 (cond ((beta-reduce body) => (lambda (brb) (list 'lambda param brb))) ; brb = beta-reduced body
					   (else #f))))
					 
			  (else 					; application
				(let ((e1 (car e))
					  (e2 (cadr e)))
				  (cond ((beta-reduce e1) => (lambda (bre1) (list bre1 e2)))
						((beta-reduce e2) => (lambda (bre2) (list e1 bre2)))
						((and (pair? e1)
							  (equal? (car e1) 'lambda))
						 (let ((param (cadr e1))
							   (body (caddr e1)))
							   replace-in-term param e2 body))
						(else #f)))))))
						
(define replace-in-term
	(lambda (old new e)
		(cond ((equal? old e) new)			; e is target variable
			  ((symbol? e) e)				; e isn't target variable
			  ((equal? (car e) 'lambda)		; e is lambda-expression
			   (let ((param (cadr e))
					 (body (caddr e)))
				 (cond ((equal? old param) e)
					   ((member param (free-variables new))
						(let ((nv (gensym)))
						(list 'lambda
							  nv
							  (replace-in-term old new
											   (replace-in-term param nv body)))))
					(list 'lambda param (replace-in-term old new body)))))
			   (else						; e is application
				(list (replace-in-term old new (car e))
					  (replace-in-term old new (cadr e)))))))))